package pullrequests

import (
	"os"
	"path/filepath"
	"strings"
)

// DefaultGeneratedPatterns contains common patterns for auto-generated files.
var DefaultGeneratedPatterns = []string{
	// Protocol Buffers
	"*.pb.go",
	"*_pb2.py",
	"*_pb2_grpc.py",
	"*.pb.h",
	"*.pb.cc",
	"*.pb.swift",

	// gRPC
	"*_grpc.pb.go",

	// GraphQL
	"*.generated.ts",
	"*.generated.tsx",
	"*Generated.swift",

	// OpenAPI / Swagger
	"*_gen.go",
	"*_client.go", // Often generated API clients

	// Generic generated markers
	"*_generated.go",
	"*_generated.ts",
	"*_generated.js",
	"*.gen.go",
	"*.gen.ts",
	"generated_*.go",

	// Mock files (often auto-generated)
	"mock_*.go",
	"*_mock.go",
	"**/mocks/*.go",
	"**/__mocks__/*.js",
	"**/__mocks__/*.ts",

	// Vendor/dependencies (often copied, not human-written)
	"vendor/**",
	"node_modules/**",

	// Lock files
	"package-lock.json",
	"yarn.lock",
	"go.sum",
	"Pipfile.lock",
	"poetry.lock",
	"Cargo.lock",

	// IDE / Build artifacts that sometimes get committed
	"*.min.js",
	"*.min.css",
	"*.bundle.js",

	// Compiled/transpiled output
	"dist/**",
	"build/**",

	// SQL migrations (auto-generated by sqlc etc)
	"**/sqlc/*.sql.go",

	// Thrift
	"*.thrift.go",
	"gen-go/**",
	"gen-py/**",

	// Avro
	"*.avsc.go",
}

// FileClassifier determines if files are auto-generated based on patterns.
type FileClassifier struct {
	patterns []string
}

// NewFileClassifier creates a classifier with default patterns plus any
// additional patterns from the GENERATED_FILE_PATTERNS environment variable.
func NewFileClassifier() *FileClassifier {
	patterns := make([]string, len(DefaultGeneratedPatterns))
	copy(patterns, DefaultGeneratedPatterns)

	// Add patterns from environment variable (comma-separated)
	if envPatterns := os.Getenv("GENERATED_FILE_PATTERNS"); envPatterns != "" {
		for _, p := range strings.Split(envPatterns, ",") {
			p = strings.TrimSpace(p)
			if p != "" {
				patterns = append(patterns, p)
			}
		}
	}

	return &FileClassifier{patterns: patterns}
}

// NewFileClassifierWithPatterns creates a classifier with custom patterns.
func NewFileClassifierWithPatterns(patterns []string) *FileClassifier {
	return &FileClassifier{patterns: patterns}
}

// IsGenerated checks if a file path matches any of the generated file patterns.
func (c *FileClassifier) IsGenerated(filePath string) bool {
	// Normalize path separators
	normalizedPath := filepath.ToSlash(filePath)

	for _, pattern := range c.patterns {
		if c.matchPattern(normalizedPath, pattern) {
			return true
		}
	}
	return false
}

// matchPattern checks if a path matches a glob-like pattern.
// Supports:
// - * matches any sequence of non-separator characters
// - ** matches any sequence including separators (recursive)
// - ? matches any single non-separator character
func (c *FileClassifier) matchPattern(path, pattern string) bool {
	// Handle ** patterns (recursive matching)
	if strings.Contains(pattern, "**") {
		return c.matchDoubleStarPattern(path, pattern)
	}

	// For simple patterns without path separators, match against filename only
	if !strings.Contains(pattern, "/") {
		filename := filepath.Base(path)
		matched, _ := filepath.Match(pattern, filename)
		return matched
	}

	// For patterns with path separators, try matching against full path
	matched, _ := filepath.Match(pattern, path)
	if matched {
		return true
	}

	// Also try matching against the end of the path
	pathParts := strings.Split(path, "/")
	patternParts := strings.Split(pattern, "/")

	if len(pathParts) >= len(patternParts) {
		suffix := strings.Join(pathParts[len(pathParts)-len(patternParts):], "/")
		matched, _ = filepath.Match(pattern, suffix)
		return matched
	}

	return false
}

// matchDoubleStarPattern handles patterns with ** (recursive matching).
func (c *FileClassifier) matchDoubleStarPattern(path, pattern string) bool {
	// Split pattern by **
	parts := strings.Split(pattern, "**")

	if len(parts) == 2 {
		prefix := strings.TrimSuffix(parts[0], "/")
		suffix := strings.TrimPrefix(parts[1], "/")

		// Check if path starts with prefix (if prefix is not empty)
		if prefix != "" && !strings.HasPrefix(path, prefix+"/") && path != prefix {
			return false
		}

		// Check if path ends with suffix pattern
		if suffix != "" {
			// Get the part of path after any prefix
			remaining := path
			if prefix != "" {
				remaining = strings.TrimPrefix(path, prefix+"/")
			}

			// Check all possible suffixes
			parts := strings.Split(remaining, "/")
			for i := 0; i < len(parts); i++ {
				testPath := strings.Join(parts[i:], "/")
				matched, _ := filepath.Match(suffix, testPath)
				if matched {
					return true
				}
				// Also try matching just the filename
				if i == len(parts)-1 {
					matched, _ = filepath.Match(suffix, parts[i])
					if matched {
						return true
					}
				}
			}
			return false
		}

		// Pattern ends with ** - matches anything under prefix
		return true
	}

	return false
}

// ClassifyFiles classifies a list of files and returns generated/human counts.
func (c *FileClassifier) ClassifyFiles(files []FileChange) (generated, human []FileChange) {
	for _, f := range files {
		if c.IsGenerated(f.Path) {
			generated = append(generated, f)
		} else {
			human = append(human, f)
		}
	}
	return
}

// FileChange represents a file change with classification info.
type FileChange struct {
	Path        string
	Additions   int
	Deletions   int
	Status      string
	IsGenerated bool
}

// GetPatterns returns the current list of patterns (useful for debugging/logging).
func (c *FileClassifier) GetPatterns() []string {
	return c.patterns
}
