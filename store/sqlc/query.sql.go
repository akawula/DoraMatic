// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPullRequests = `-- name: CountPullRequests :one
SELECT COUNT(DISTINCT p.id)::int -- Count distinct PR IDs
FROM prs p
LEFT JOIN teams t ON p.author = t.member -- Join with teams table
WHERE
    p.merged_at >= $1::timestamptz -- Ensure this matches ListPullRequests criteria
    AND p.merged_at <= $2::timestamptz
    AND ( -- Filter by search term (title, author, or JIRA reference)
        $3::text = '' OR
        p.title ILIKE '%' || $3::text || '%' OR
        p.author ILIKE '%' || $3::text || '%' OR
        EXISTS (
            SELECT 1
            FROM regexp_matches(COALESCE(p.title, '') || ' ' || COALESCE(p.branch_name, ''), '([A-Z]+-[0-9]+)', 'g') AS s(jira_id_arr)
            WHERE jira_id_arr[1] ILIKE ('%' || $3::text || '%')
        )
    )
    AND ( -- Optionally filter by team name
        $4::text = '' OR
        t.team = $4::text
    )
    AND ( -- Optionally filter by state
        $5::text = '' OR
        p.state ILIKE '%' || $5::text || '%'
    )
    AND ( -- Optionally filter by author (case-insensitive)
        $6::text = '' OR
        p.author ILIKE '%' || $6::text || '%'
    )
    AND ($7::text[] IS NULL OR p.author = ANY($7::text[]))
`

type CountPullRequestsParams struct {
	StartDate    time.Time `db:"start_date"`
	EndDate      time.Time `db:"end_date"`
	SearchTerm   string    `db:"search_term"`
	TeamName     string    `db:"team_name"`
	FilterState  string    `db:"filter_state"`
	FilterAuthor string    `db:"filter_author"`
	Members      []string  `db:"members"`
}

func (q *Queries) CountPullRequests(ctx context.Context, arg CountPullRequestsParams) (int32, error) {
	row := q.db.QueryRow(ctx, countPullRequests,
		arg.StartDate,
		arg.EndDate,
		arg.SearchTerm,
		arg.TeamName,
		arg.FilterState,
		arg.FilterAuthor,
		arg.Members,
	)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countPullRequestsWithJiraReferences = `-- name: CountPullRequestsWithJiraReferences :one
SELECT COUNT(DISTINCT p.id) -- Ensure distinct PRs are counted
FROM prs p
LEFT JOIN teams t ON p.author = t.member -- Join with teams table
WHERE
    (COALESCE(p.title, '') ~ '[A-Z]+-[0-9]+' OR COALESCE(p.branch_name, '') ~ '[A-Z]+-[0-9]+')
    AND p.created_at >= $1::timestamptz
    AND p.created_at <= $2::timestamptz
    AND ($3::text = '' OR
         p.title ILIKE '%' || $3::text || '%' OR
         p.branch_name ILIKE '%' || $3::text || '%' OR
         p.author ILIKE '%' || $3::text || '%')
    AND ($4::text = '' OR t.team = $4::text)
    AND ($5::text[] IS NULL OR p.author = ANY($5::text[]))
`

type CountPullRequestsWithJiraReferencesParams struct {
	StartDate      time.Time `db:"start_date"`
	EndDate        time.Time `db:"end_date"`
	TextSearchTerm string    `db:"text_search_term"`
	TeamName       string    `db:"team_name"`
	Members        []string  `db:"members"`
}

func (q *Queries) CountPullRequestsWithJiraReferences(ctx context.Context, arg CountPullRequestsWithJiraReferencesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countPullRequestsWithJiraReferences,
		arg.StartDate,
		arg.EndDate,
		arg.TextSearchTerm,
		arg.TeamName,
		arg.Members,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countRepositories = `-- name: CountRepositories :one

SELECT count(*) FROM repositories
WHERE ($1::text = '' OR slug ILIKE '%' || $1 || '%')
`

// Repositories --
func (q *Queries) CountRepositories(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countRepositories, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTeamCommitsByDateRange = `-- name: CountTeamCommitsByDateRange :one

SELECT COUNT(c.id)::int -- Cast to int for Go compatibility
FROM commits c
JOIN prs p ON c.pr_id = p.id
JOIN teams t ON p.author = t.member
WHERE t.team = $1
  AND ($2::text[] IS NULL OR p.author = ANY($2::text[])) -- Filter by selected members
  AND p.state = 'MERGED'       -- Only consider PRs that are merged
  AND p.merged_at >= $3::timestamptz      -- Filter by PR merge date
  AND p.merged_at <= $4::timestamptz
`

type CountTeamCommitsByDateRangeParams struct {
	TeamName          string    `db:"team_name"`
	Members           []string  `db:"members"`
	MergedAtStartDate time.Time `db:"merged_at_start_date"`
	MergedAtEndDate   time.Time `db:"merged_at_end_date"`
}

// Team Statistics --
func (q *Queries) CountTeamCommitsByDateRange(ctx context.Context, arg CountTeamCommitsByDateRangeParams) (int32, error) {
	row := q.db.QueryRow(ctx, countTeamCommitsByDateRange,
		arg.TeamName,
		arg.Members,
		arg.MergedAtStartDate,
		arg.MergedAtEndDate,
	)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createRepository = `-- name: CreateRepository :exec
INSERT INTO repositories (org, slug, language)
VALUES ($1, $2, $3)
`

type CreateRepositoryParams struct {
	Org      string      `db:"org"`
	Slug     string      `db:"slug"`
	Language pgtype.Text `db:"language"`
}

func (q *Queries) CreateRepository(ctx context.Context, arg CreateRepositoryParams) error {
	_, err := q.db.Exec(ctx, createRepository, arg.Org, arg.Slug, arg.Language)
	return err
}

const createTeamMember = `-- name: CreateTeamMember :exec
INSERT INTO teams (team, member, avatar_url)
VALUES ($1, $2, $3)
`

type CreateTeamMemberParams struct {
	Team      string         `db:"team"`
	Member    string         `db:"member"`
	AvatarUrl sql.NullString `db:"avatar_url"`
}

func (q *Queries) CreateTeamMember(ctx context.Context, arg CreateTeamMemberParams) error {
	_, err := q.db.Exec(ctx, createTeamMember, arg.Team, arg.Member, arg.AvatarUrl)
	return err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (
    username,
    hashed_password
) VALUES (
    $1, $2
)
RETURNING id, username, hashed_password, created_at, updated_at
`

type CreateUserParams struct {
	Username       string `db:"username"`
	HashedPassword string `db:"hashed_password"`
}

// Users --
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser, arg.Username, arg.HashedPassword)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.HashedPassword,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRepositoryOwners = `-- name: DeleteRepositoryOwners :exec
DELETE FROM repository_owners WHERE org = $1 AND repo_slug = $2
`

type DeleteRepositoryOwnersParams struct {
	Org      string `db:"org"`
	RepoSlug string `db:"repo_slug"`
}

func (q *Queries) DeleteRepositoryOwners(ctx context.Context, arg DeleteRepositoryOwnersParams) error {
	_, err := q.db.Exec(ctx, deleteRepositoryOwners, arg.Org, arg.RepoSlug)
	return err
}

const diagnoseLeadTimes = `-- name: DiagnoseLeadTimes :many

WITH FirstCommitPerPR AS (
    SELECT
        pr_id,
        MIN(created_at) as first_commit_at
    FROM commits
    GROUP BY pr_id
)
SELECT
    p.id AS pr_id,
    p.created_at AS pr_created_at,
    p.review_requested_at AS pr_review_requested_at, -- This is the field to use
    p.merged_at AS pr_merged_at,
    fc.first_commit_at,
    p.review_requested_at AS first_review_at -- Use p.review_requested_at directly
FROM prs p
LEFT JOIN FirstCommitPerPR fc ON p.id = fc.pr_id
WHERE p.state = 'MERGED'
ORDER BY p.merged_at DESC
LIMIT 10
`

type DiagnoseLeadTimesRow struct {
	PrID                string             `db:"pr_id"`
	PrCreatedAt         time.Time          `db:"pr_created_at"`
	PrReviewRequestedAt pgtype.Timestamptz `db:"pr_review_requested_at"`
	PrMergedAt          pgtype.Timestamptz `db:"pr_merged_at"`
	FirstCommitAt       interface{}        `db:"first_commit_at"`
	FirstReviewAt       pgtype.Timestamptz `db:"first_review_at"`
}

// Filter by selected members
// FirstReviewPerPR AS ( -- No longer needed
//
//	SELECT
//	    pull_request_id,
//	    MIN(submitted_at) as first_review_at
//	FROM pull_request_reviews
//	WHERE state = 'APPROVED' OR state = 'CHANGES_REQUESTED'
//	GROUP BY pull_request_id
//
// ) -- No longer needed
// LEFT JOIN FirstReviewPerPR fr ON p.id = fr.pull_request_id -- No longer needed
func (q *Queries) DiagnoseLeadTimes(ctx context.Context) ([]DiagnoseLeadTimesRow, error) {
	rows, err := q.db.Query(ctx, diagnoseLeadTimes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiagnoseLeadTimesRow{}
	for rows.Next() {
		var i DiagnoseLeadTimesRow
		if err := rows.Scan(
			&i.PrID,
			&i.PrCreatedAt,
			&i.PrReviewRequestedAt,
			&i.PrMergedAt,
			&i.FirstCommitAt,
			&i.FirstReviewAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchSecurityPullRequests = `-- name: FetchSecurityPullRequests :many
SELECT
    p.id, p.url, p.title, p.repository_name, p.repository_owner, p.author,
    p.additions, p.deletions, p.state, p.created_at, p.merged_at
FROM teams t
INNER JOIN prs p ON p.author = t.member
WHERE
    (p.created_at >= date_trunc('day', current_timestamp) - interval '1 day' AND p.state = 'OPEN')
    OR
    (p.merged_at >= date_trunc('day', current_timestamp) - interval '1 day' AND p.state = 'MERGED')
AND t.team IN (
    'pe-customer-journey', 'PE Platform Insights', 'Webstack', 'Omnibus', 'CSI',
    'pe-platform-fleet', 'ie-deploy', 'P&E - Team Domino', 'Ares', 'RD-Edge',
    'Golden', 'RD - Production Engineering', 'Security Engineering'
)
GROUP BY p.id
ORDER BY p.additions + p.deletions DESC
`

type FetchSecurityPullRequestsRow struct {
	ID              string             `db:"id"`
	Url             sql.NullString     `db:"url"`
	Title           sql.NullString     `db:"title"`
	RepositoryName  pgtype.Text        `db:"repository_name"`
	RepositoryOwner pgtype.Text        `db:"repository_owner"`
	Author          pgtype.Text        `db:"author"`
	Additions       pgtype.Int4        `db:"additions"`
	Deletions       pgtype.Int4        `db:"deletions"`
	State           pgtype.Text        `db:"state"`
	CreatedAt       time.Time          `db:"created_at"`
	MergedAt        pgtype.Timestamptz `db:"merged_at"`
}

func (q *Queries) FetchSecurityPullRequests(ctx context.Context) ([]FetchSecurityPullRequestsRow, error) {
	rows, err := q.db.Query(ctx, fetchSecurityPullRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchSecurityPullRequestsRow{}
	for rows.Next() {
		var i FetchSecurityPullRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.RepositoryName,
			&i.RepositoryOwner,
			&i.Author,
			&i.Additions,
			&i.Deletions,
			&i.State,
			&i.CreatedAt,
			&i.MergedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRepositories = `-- name: GetAllRepositories :many
SELECT org, slug, language FROM repositories
`

func (q *Queries) GetAllRepositories(ctx context.Context) ([]Repository, error) {
	rows, err := q.db.Query(ctx, getAllRepositories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Repository{}
	for rows.Next() {
		var i Repository
		if err := rows.Scan(&i.Org, &i.Slug, &i.Language); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRepositoryOwners = `-- name: GetAllRepositoryOwners :many
SELECT org, repo_slug, team_slug FROM repository_owners
`

func (q *Queries) GetAllRepositoryOwners(ctx context.Context) ([]RepositoryOwner, error) {
	rows, err := q.db.Query(ctx, getAllRepositoryOwners)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RepositoryOwner{}
	for rows.Next() {
		var i RepositoryOwner
		if err := rows.Scan(&i.Org, &i.RepoSlug, &i.TeamSlug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistinctTeamsWithGithubSlug = `-- name: GetDistinctTeamsWithGithubSlug :many
SELECT DISTINCT team, github_team_slug
FROM teams WHERE github_team_slug IS NOT NULL
`

type GetDistinctTeamsWithGithubSlugRow struct {
	Team           string      `db:"team"`
	GithubTeamSlug pgtype.Text `db:"github_team_slug"`
}

func (q *Queries) GetDistinctTeamsWithGithubSlug(ctx context.Context) ([]GetDistinctTeamsWithGithubSlugRow, error) {
	rows, err := q.db.Query(ctx, getDistinctTeamsWithGithubSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDistinctTeamsWithGithubSlugRow{}
	for rows.Next() {
		var i GetDistinctTeamsWithGithubSlugRow
		if err := rows.Scan(&i.Team, &i.GithubTeamSlug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForeignPRMetricsByTeam = `-- name: GetForeignPRMetricsByTeam :many

WITH AuthorTeamSlugs AS (
    SELECT DISTINCT p.id as pr_id, t.github_team_slug, t.team
    FROM prs p
    JOIN teams t ON p.author = t.member
    WHERE t.github_team_slug IS NOT NULL
),
ForeignPRs AS (
    SELECT
        p.id as pr_id,
        ats.team,
        p.created_at,
        p.review_requested_at,
        p.merged_at,
        p.state
    FROM prs p
    JOIN AuthorTeamSlugs ats ON ats.pr_id = p.id
    WHERE NOT EXISTS (
        SELECT 1 FROM repository_owners ro
        WHERE ro.org = p.repository_owner
          AND ro.repo_slug = p.repository_name
          AND ro.team_slug = ats.github_team_slug
    )
)
SELECT
    fp.team,
    COUNT(*) FILTER (WHERE fp.state = 'OPEN')::int as open_foreign_prs,
    COUNT(*) FILTER (WHERE fp.state = 'MERGED')::int as merged_foreign_prs,
    COALESCE(AVG(
        CASE
            WHEN fp.state = 'MERGED' AND fp.merged_at IS NOT NULL AND fp.review_requested_at IS NOT NULL
            THEN EXTRACT(EPOCH FROM (fp.merged_at - fp.review_requested_at))
            ELSE NULL
        END
    ), 0)::float as avg_time_to_merge_seconds
FROM ForeignPRs fp
WHERE fp.created_at >= $1::timestamptz
  AND fp.created_at <= $2::timestamptz
GROUP BY fp.team
ORDER BY open_foreign_prs DESC, avg_time_to_merge_seconds DESC
`

type GetForeignPRMetricsByTeamParams struct {
	StartDate time.Time `db:"start_date"`
	EndDate   time.Time `db:"end_date"`
}

type GetForeignPRMetricsByTeamRow struct {
	Team                  string  `db:"team"`
	OpenForeignPrs        int32   `db:"open_foreign_prs"`
	MergedForeignPrs      int32   `db:"merged_foreign_prs"`
	AvgTimeToMergeSeconds float64 `db:"avg_time_to_merge_seconds"`
}

// Foreign PR Metrics by Team --
// Shows teams that have PRs waiting in foreign repos
func (q *Queries) GetForeignPRMetricsByTeam(ctx context.Context, arg GetForeignPRMetricsByTeamParams) ([]GetForeignPRMetricsByTeamRow, error) {
	rows, err := q.db.Query(ctx, getForeignPRMetricsByTeam, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetForeignPRMetricsByTeamRow{}
	for rows.Next() {
		var i GetForeignPRMetricsByTeamRow
		if err := rows.Scan(
			&i.Team,
			&i.OpenForeignPrs,
			&i.MergedForeignPrs,
			&i.AvgTimeToMergeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getForeignPRsByTeam = `-- name: GetForeignPRsByTeam :many

WITH AuthorTeams AS (
    -- Get all teams the PR author belongs to (via github_team_slug)
    SELECT DISTINCT p.id as pr_id, t.github_team_slug
    FROM prs p
    JOIN teams t ON p.author = t.member
    WHERE t.github_team_slug IS NOT NULL
),
PROwnership AS (
    -- Check if author is in any team that owns the repo
    SELECT
        p.id as pr_id,
        CASE
            WHEN EXISTS (
                SELECT 1 FROM repository_owners ro
                JOIN AuthorTeams at ON at.pr_id = p.id AND ro.team_slug = at.github_team_slug
                WHERE ro.org = p.repository_owner AND ro.repo_slug = p.repository_name
            ) THEN false
            ELSE true
        END as is_foreign
    FROM prs p
)
SELECT
    p.id,
    p.url,
    p.title,
    p.repository_name,
    p.repository_owner,
    p.author,
    p.state,
    p.created_at,
    p.merged_at,
    p.review_requested_at,
    po.is_foreign
FROM prs p
JOIN teams t ON p.author = t.member
JOIN PROwnership po ON p.id = po.pr_id
WHERE t.team = $1
  AND po.is_foreign = true
  AND p.state = $2
  AND p.created_at >= $3::timestamptz
  AND p.created_at <= $4::timestamptz
GROUP BY p.id, p.url, p.title, p.repository_name, p.repository_owner,
         p.author, p.state, p.created_at, p.merged_at, p.review_requested_at, po.is_foreign
ORDER BY p.created_at DESC
`

type GetForeignPRsByTeamParams struct {
	TeamName  string      `db:"team_name"`
	PrState   pgtype.Text `db:"pr_state"`
	StartDate time.Time   `db:"start_date"`
	EndDate   time.Time   `db:"end_date"`
}

type GetForeignPRsByTeamRow struct {
	ID                string             `db:"id"`
	Url               sql.NullString     `db:"url"`
	Title             sql.NullString     `db:"title"`
	RepositoryName    pgtype.Text        `db:"repository_name"`
	RepositoryOwner   pgtype.Text        `db:"repository_owner"`
	Author            pgtype.Text        `db:"author"`
	State             pgtype.Text        `db:"state"`
	CreatedAt         time.Time          `db:"created_at"`
	MergedAt          pgtype.Timestamptz `db:"merged_at"`
	ReviewRequestedAt pgtype.Timestamptz `db:"review_requested_at"`
	IsForeign         bool               `db:"is_foreign"`
}

// Foreign PR Detection --
// A PR is "foreign" if the author is not a member of any team that owns the repository
func (q *Queries) GetForeignPRsByTeam(ctx context.Context, arg GetForeignPRsByTeamParams) ([]GetForeignPRsByTeamRow, error) {
	rows, err := q.db.Query(ctx, getForeignPRsByTeam,
		arg.TeamName,
		arg.PrState,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetForeignPRsByTeamRow{}
	for rows.Next() {
		var i GetForeignPRsByTeamRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.RepositoryName,
			&i.RepositoryOwner,
			&i.Author,
			&i.State,
			&i.CreatedAt,
			&i.MergedAt,
			&i.ReviewRequestedAt,
			&i.IsForeign,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastPullRequestMergedDate = `-- name: GetLastPullRequestMergedDate :one

SELECT merged_at FROM prs
WHERE state = $1 AND repository_owner = $2 AND repository_name = $3
ORDER BY merged_at DESC
LIMIT 1
`

type GetLastPullRequestMergedDateParams struct {
	State           pgtype.Text `db:"state"`
	RepositoryOwner pgtype.Text `db:"repository_owner"`
	RepositoryName  pgtype.Text `db:"repository_name"`
}

// Pull Requests (prs) --
func (q *Queries) GetLastPullRequestMergedDate(ctx context.Context, arg GetLastPullRequestMergedDateParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getLastPullRequestMergedDate, arg.State, arg.RepositoryOwner, arg.RepositoryName)
	var merged_at pgtype.Timestamptz
	err := row.Scan(&merged_at)
	return merged_at, err
}

const getPullRequestTimeDataForStats = `-- name: GetPullRequestTimeDataForStats :many
WITH FirstCommitPerPR AS (
    SELECT
        pr_id,
        MIN(created_at) as first_commit_at
    FROM commits
    GROUP BY pr_id
),
FirstActualReviewPerPR AS (
    SELECT
        pull_request_id,
        MIN(submitted_at) as first_actual_review_at
    FROM pull_request_reviews
    WHERE state = 'APPROVED' OR state = 'CHANGES_REQUESTED'
    GROUP BY pull_request_id
)
SELECT
    p.id AS pr_id,
    p.created_at AS pr_created_at,
    p.state AS pr_state,
    p.merged_at AS pr_merged_at,
    p.review_requested_at AS pr_review_requested_at,
    p.reviews_requested AS pr_reviews_requested, -- Added for avg reviews requested count
    fc.first_commit_at,
    far.first_actual_review_at
FROM prs p
LEFT JOIN teams t ON p.author = t.member -- Join with teams to filter by team_name
LEFT JOIN FirstCommitPerPR fc ON p.id = fc.pr_id
LEFT JOIN FirstActualReviewPerPR far ON p.id = far.pull_request_id
WHERE
    t.team = $1
    AND ($2::text[] IS NULL OR p.author = ANY($2::text[]))
    AND (
        -- Include PRs relevant for any lead time calculation or stats within the period
        -- Merged PRs within the period
        (p.state = 'MERGED' AND p.merged_at >= $3::timestamptz AND p.merged_at <= $4::timestamptz) OR
        -- PRs created within the period (relevant for 'time to code', 'time to first review' even if not merged in period)
        (p.created_at >= $3::timestamptz AND p.created_at <= $4::timestamptz) OR
        -- PRs that had review requested within the period
        (p.review_requested_at >= $3::timestamptz AND p.review_requested_at <= $4::timestamptz)
        -- Note: This might fetch more PRs than strictly needed for *averages* if averages are only for merged PRs.
        -- The Go code will need to filter appropriately for each specific metric.
    )
`

type GetPullRequestTimeDataForStatsParams struct {
	TeamName  string    `db:"team_name"`
	Members   []string  `db:"members"`
	StartDate time.Time `db:"start_date"`
	EndDate   time.Time `db:"end_date"`
}

type GetPullRequestTimeDataForStatsRow struct {
	PrID                string             `db:"pr_id"`
	PrCreatedAt         time.Time          `db:"pr_created_at"`
	PrState             pgtype.Text        `db:"pr_state"`
	PrMergedAt          pgtype.Timestamptz `db:"pr_merged_at"`
	PrReviewRequestedAt pgtype.Timestamptz `db:"pr_review_requested_at"`
	PrReviewsRequested  pgtype.Int4        `db:"pr_reviews_requested"`
	FirstCommitAt       interface{}        `db:"first_commit_at"`
	FirstActualReviewAt interface{}        `db:"first_actual_review_at"`
}

func (q *Queries) GetPullRequestTimeDataForStats(ctx context.Context, arg GetPullRequestTimeDataForStatsParams) ([]GetPullRequestTimeDataForStatsRow, error) {
	rows, err := q.db.Query(ctx, getPullRequestTimeDataForStats,
		arg.TeamName,
		arg.Members,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPullRequestTimeDataForStatsRow{}
	for rows.Next() {
		var i GetPullRequestTimeDataForStatsRow
		if err := rows.Scan(
			&i.PrID,
			&i.PrCreatedAt,
			&i.PrState,
			&i.PrMergedAt,
			&i.PrReviewRequestedAt,
			&i.PrReviewsRequested,
			&i.FirstCommitAt,
			&i.FirstActualReviewAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepositoryOwners = `-- name: GetRepositoryOwners :many
SELECT team_slug FROM repository_owners WHERE org = $1 AND repo_slug = $2
`

type GetRepositoryOwnersParams struct {
	Org      string `db:"org"`
	RepoSlug string `db:"repo_slug"`
}

func (q *Queries) GetRepositoryOwners(ctx context.Context, arg GetRepositoryOwnersParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getRepositoryOwners, arg.Org, arg.RepoSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var team_slug string
		if err := rows.Scan(&team_slug); err != nil {
			return nil, err
		}
		items = append(items, team_slug)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlowReviewingTeams = `-- name: GetSlowReviewingTeams :many

WITH FirstReviewByOwnerTeam AS (
    SELECT
        prr.pull_request_id,
        ro.team_slug,
        MIN(prr.submitted_at) as first_review_at
    FROM pull_request_reviews prr
    JOIN prs p ON prr.pull_request_id = p.id
    JOIN repository_owners ro ON ro.org = p.repository_owner AND ro.repo_slug = p.repository_name
    JOIN teams t ON t.github_team_slug = ro.team_slug AND prr.author_login = t.member
    WHERE prr.state IN ('APPROVED', 'CHANGES_REQUESTED')
    GROUP BY prr.pull_request_id, ro.team_slug
)
SELECT
    ro.team_slug,
    COUNT(DISTINCT p.id)::int as total_prs_to_review,
    COUNT(DISTINCT CASE WHEN p.state = 'OPEN' AND fr.first_review_at IS NULL THEN p.id END)::int as pending_reviews,
    COALESCE(AVG(
        CASE
            WHEN fr.first_review_at IS NOT NULL AND p.review_requested_at IS NOT NULL
                 AND fr.first_review_at > p.review_requested_at
            THEN EXTRACT(EPOCH FROM (fr.first_review_at - p.review_requested_at))
            ELSE NULL
        END
    ), 0)::float as avg_time_to_first_review_seconds
FROM prs p
JOIN repository_owners ro ON ro.org = p.repository_owner AND ro.repo_slug = p.repository_name
LEFT JOIN FirstReviewByOwnerTeam fr ON fr.pull_request_id = p.id AND fr.team_slug = ro.team_slug
WHERE NOT EXISTS (
    SELECT 1 FROM teams t
    WHERE t.member = p.author AND t.github_team_slug = ro.team_slug
)
AND p.created_at >= $1::timestamptz
AND p.created_at <= $2::timestamptz
GROUP BY ro.team_slug
HAVING COUNT(DISTINCT p.id) > 0
ORDER BY pending_reviews DESC, avg_time_to_first_review_seconds DESC
`

type GetSlowReviewingTeamsParams struct {
	StartDate time.Time `db:"start_date"`
	EndDate   time.Time `db:"end_date"`
}

type GetSlowReviewingTeamsRow struct {
	TeamSlug                    string  `db:"team_slug"`
	TotalPrsToReview            int32   `db:"total_prs_to_review"`
	PendingReviews              int32   `db:"pending_reviews"`
	AvgTimeToFirstReviewSeconds float64 `db:"avg_time_to_first_review_seconds"`
}

// Teams Slow at Reviewing (as code owners) --
// Shows teams that own repos but are slow to review PRs from non-members
// Exclude PRs from authors who are members of the owning team
func (q *Queries) GetSlowReviewingTeams(ctx context.Context, arg GetSlowReviewingTeamsParams) ([]GetSlowReviewingTeamsRow, error) {
	rows, err := q.db.Query(ctx, getSlowReviewingTeams, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetSlowReviewingTeamsRow{}
	for rows.Next() {
		var i GetSlowReviewingTeamsRow
		if err := rows.Scan(
			&i.TeamSlug,
			&i.TotalPrsToReview,
			&i.PendingReviews,
			&i.AvgTimeToFirstReviewSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamByGithubSlug = `-- name: GetTeamByGithubSlug :many
SELECT team, member, avatar_url, github_team_slug
FROM teams WHERE github_team_slug = $1
`

func (q *Queries) GetTeamByGithubSlug(ctx context.Context, githubTeamSlug pgtype.Text) ([]Team, error) {
	rows, err := q.db.Query(ctx, getTeamByGithubSlug, githubTeamSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.Team,
			&i.Member,
			&i.AvatarUrl,
			&i.GithubTeamSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMemberReviewStatsByDateRange = `-- name: GetTeamMemberReviewStatsByDateRange :many
SELECT
    prr.author_login,
    COUNT(prr.id) AS total_reviews_submitted,
    SUM(CASE WHEN prr.state = 'APPROVED' THEN 1 ELSE 0 END) AS approved_reviews,
    SUM(CASE WHEN prr.state = 'CHANGES_REQUESTED' THEN 1 ELSE 0 END) AS changes_requested_reviews,
    SUM(CASE WHEN prr.state = 'COMMENTED' THEN 1 ELSE 0 END) AS commented_reviews
FROM
    pull_request_reviews prr
INNER JOIN teams t ON prr.author_login = t.member -- Ensure reviewer is in the specified team
WHERE t.team = $1
  AND ($2::text[] IS NULL OR prr.author_login = ANY($2::text[])) -- Further filter by selected members if provided
  AND prr.submitted_at >= $3::timestamptz
  AND prr.submitted_at <= $4::timestamptz
GROUP BY
    prr.author_login
ORDER BY
    total_reviews_submitted DESC
`

type GetTeamMemberReviewStatsByDateRangeParams struct {
	TeamName  string    `db:"team_name"`
	Members   []string  `db:"members"`
	StartDate time.Time `db:"start_date"`
	EndDate   time.Time `db:"end_date"`
}

type GetTeamMemberReviewStatsByDateRangeRow struct {
	AuthorLogin             sql.NullString `db:"author_login"`
	TotalReviewsSubmitted   int64          `db:"total_reviews_submitted"`
	ApprovedReviews         int64          `db:"approved_reviews"`
	ChangesRequestedReviews int64          `db:"changes_requested_reviews"`
	CommentedReviews        int64          `db:"commented_reviews"`
}

func (q *Queries) GetTeamMemberReviewStatsByDateRange(ctx context.Context, arg GetTeamMemberReviewStatsByDateRangeParams) ([]GetTeamMemberReviewStatsByDateRangeRow, error) {
	rows, err := q.db.Query(ctx, getTeamMemberReviewStatsByDateRange,
		arg.TeamName,
		arg.Members,
		arg.StartDate,
		arg.EndDate,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTeamMemberReviewStatsByDateRangeRow{}
	for rows.Next() {
		var i GetTeamMemberReviewStatsByDateRangeRow
		if err := rows.Scan(
			&i.AuthorLogin,
			&i.TotalReviewsSubmitted,
			&i.ApprovedReviews,
			&i.ChangesRequestedReviews,
			&i.CommentedReviews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamMembers = `-- name: GetTeamMembers :many
SELECT member, avatar_url
FROM teams
WHERE team = $1
ORDER BY member
`

type GetTeamMembersRow struct {
	Member    string         `db:"member"`
	AvatarUrl sql.NullString `db:"avatar_url"`
}

func (q *Queries) GetTeamMembers(ctx context.Context, team string) ([]GetTeamMembersRow, error) {
	rows, err := q.db.Query(ctx, getTeamMembers, team)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTeamMembersRow{}
	for rows.Next() {
		var i GetTeamMembersRow
		if err := rows.Scan(&i.Member, &i.AvatarUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamPullRequestStatsByDateRange = `-- name: GetTeamPullRequestStatsByDateRange :one

WITH FirstCommitPerPR AS (
    SELECT
        pr_id,
        MIN(created_at) as first_commit_at
    FROM commits
    GROUP BY pr_id
),
FirstActualReviewPerPR AS (
    SELECT
        pull_request_id,
        MIN(submitted_at) as first_actual_review_at
    FROM pull_request_reviews
    WHERE state = 'APPROVED' OR state = 'CHANGES_REQUESTED' -- Consider only substantive reviews
    GROUP BY pull_request_id
),
TeamMemberReviewStats AS (
    SELECT
        COUNT(prr.id) AS total_team_reviews_submitted_val,
        COUNT(DISTINCT prr.author_login) AS distinct_team_reviewers_count_val
    FROM pull_request_reviews prr
    INNER JOIN teams t_rev ON prr.author_login = t_rev.member
    WHERE t_rev.team = $3
      AND ($4::text[] IS NULL OR prr.author_login = ANY($4::text[]))
      AND prr.submitted_at >= $1::timestamptz
      AND prr.submitted_at <= $2::timestamptz
)
SELECT
    COUNT(CASE WHEN p.state = 'MERGED' AND p.merged_at >= $1::timestamptz AND p.merged_at <= $2::timestamptz THEN 1 END)::int AS merged_count,
    COUNT(CASE WHEN p.state = 'CLOSED' AND p.created_at >= $1::timestamptz AND p.created_at <= $2::timestamptz THEN 1 END)::int AS closed_count,
    COUNT(CASE WHEN p.state = 'MERGED' AND p.merged_at >= $1::timestamptz AND p.merged_at <= $2::timestamptz AND p.title LIKE 'Revert %' THEN 1 END)::int AS rollbacks_count,
    -- Calculate average lead time to first review request in seconds
    COALESCE(AVG(
        CASE
            -- Only include PRs that have both timestamps and review requested after first commit
            WHEN p.review_requested_at IS NOT NULL AND fc.first_commit_at IS NOT NULL AND p.review_requested_at > fc.first_commit_at
            THEN EXTRACT(EPOCH FROM (p.review_requested_at - fc.first_commit_at))
            ELSE NULL
        END
    ), 0)::float AS avg_lead_time_to_code_seconds, -- Use COALESCE to return 0 if no valid PRs found, cast to float
    -- Count PRs contributing to the average lead time calculation
    COUNT(
        CASE
            WHEN p.review_requested_at IS NOT NULL AND fc.first_commit_at IS NOT NULL AND p.review_requested_at > fc.first_commit_at
            THEN 1 -- Count this PR
            ELSE NULL
        END
    )::int AS count_prs_for_avg_lead_time,
    -- Calculate average lead time from first review to merge in seconds
    COALESCE(AVG(
        CASE
            -- Only include PRs that are merged, have a first review, and the review happened before merge
            WHEN p.state = 'MERGED' AND p.merged_at IS NOT NULL AND p.review_requested_at IS NOT NULL AND p.review_requested_at < p.merged_at
            THEN EXTRACT(EPOCH FROM (p.merged_at - p.review_requested_at))
            ELSE NULL
        END
    ), 0)::float AS avg_lead_time_to_review_seconds,
    -- Calculate average lead time from first commit to merge in seconds
    COALESCE(AVG(
        CASE
            -- Only include PRs that are merged, have a first commit, and the commit happened before merge
            WHEN p.state = 'MERGED' AND p.merged_at IS NOT NULL AND fc.first_commit_at IS NOT NULL AND fc.first_commit_at < p.merged_at
            THEN EXTRACT(EPOCH FROM (p.merged_at - fc.first_commit_at))
            ELSE NULL
        END
    ), 0)::float AS avg_lead_time_to_merge_seconds,
    -- Count PRs contributing to the average lead time to merge calculation
    COUNT(
        CASE
            WHEN p.state = 'MERGED' AND p.merged_at IS NOT NULL AND fc.first_commit_at IS NOT NULL AND fc.first_commit_at < p.merged_at
            THEN 1 -- Count this PR
            ELSE NULL
        END
    )::int AS count_prs_for_avg_lead_time_to_merge,
    -- Calculate average time to first actual review in seconds
    COALESCE(AVG(
        CASE
            -- Only include PRs that have a first commit and a first actual review, and review happened after commit
            WHEN far.first_actual_review_at IS NOT NULL AND fc.first_commit_at IS NOT NULL AND far.first_actual_review_at > fc.first_commit_at
            THEN EXTRACT(EPOCH FROM (far.first_actual_review_at - fc.first_commit_at))
            ELSE NULL
        END
    ), 0)::float AS avg_time_to_first_actual_review_seconds,
    -- Count PRs contributing to the average time to first actual review
    COUNT(
        CASE
            WHEN far.first_actual_review_at IS NOT NULL AND fc.first_commit_at IS NOT NULL AND far.first_actual_review_at > fc.first_commit_at
            THEN 1
            ELSE NULL
        END
    )::int AS count_prs_for_avg_time_to_first_actual_review,
    COALESCE(SUM(CASE WHEN p.state = 'MERGED' AND p.merged_at >= $1::timestamptz AND p.merged_at <= $2::timestamptz THEN p.additions ELSE 0 END), 0)::bigint AS total_additions,
    COALESCE(SUM(CASE WHEN p.state = 'MERGED' AND p.merged_at >= $1::timestamptz AND p.merged_at <= $2::timestamptz THEN p.deletions ELSE 0 END), 0)::bigint AS total_deletions,
    COALESCE(MAX(tmrs.total_team_reviews_submitted_val), 0)::bigint AS total_team_reviews_submitted,
    COALESCE(MAX(tmrs.distinct_team_reviewers_count_val), 0)::int AS distinct_team_reviewers_count
FROM prs p
JOIN teams t ON p.author = t.member
LEFT JOIN FirstCommitPerPR fc ON p.id = fc.pr_id
LEFT JOIN FirstActualReviewPerPR far ON p.id = far.pull_request_id -- Join with first actual review data
CROSS JOIN TeamMemberReviewStats tmrs
WHERE t.team = $3
  AND ($4::text[] IS NULL OR p.author = ANY($4::text[])) -- Filter by selected members
  AND (
       (p.state = 'MERGED' AND p.merged_at >= $1::timestamptz AND p.merged_at <= $2::timestamptz) OR
       (p.state = 'CLOSED' AND p.created_at >= $1::timestamptz AND p.created_at <= $2::timestamptz)
      )
`

type GetTeamPullRequestStatsByDateRangeParams struct {
	StartDate time.Time `db:"start_date"`
	EndDate   time.Time `db:"end_date"`
	TeamName  string    `db:"team_name"`
	Members   []string  `db:"members"`
}

type GetTeamPullRequestStatsByDateRangeRow struct {
	MergedCount                           int32   `db:"merged_count"`
	ClosedCount                           int32   `db:"closed_count"`
	RollbacksCount                        int32   `db:"rollbacks_count"`
	AvgLeadTimeToCodeSeconds              float64 `db:"avg_lead_time_to_code_seconds"`
	CountPrsForAvgLeadTime                int32   `db:"count_prs_for_avg_lead_time"`
	AvgLeadTimeToReviewSeconds            float64 `db:"avg_lead_time_to_review_seconds"`
	AvgLeadTimeToMergeSeconds             float64 `db:"avg_lead_time_to_merge_seconds"`
	CountPrsForAvgLeadTimeToMerge         int32   `db:"count_prs_for_avg_lead_time_to_merge"`
	AvgTimeToFirstActualReviewSeconds     float64 `db:"avg_time_to_first_actual_review_seconds"`
	CountPrsForAvgTimeToFirstActualReview int32   `db:"count_prs_for_avg_time_to_first_actual_review"`
	TotalAdditions                        int64   `db:"total_additions"`
	TotalDeletions                        int64   `db:"total_deletions"`
	TotalTeamReviewsSubmitted             int64   `db:"total_team_reviews_submitted"`
	DistinctTeamReviewersCount            int32   `db:"distinct_team_reviewers_count"`
}

// Filter by PR merge date
func (q *Queries) GetTeamPullRequestStatsByDateRange(ctx context.Context, arg GetTeamPullRequestStatsByDateRangeParams) (GetTeamPullRequestStatsByDateRangeRow, error) {
	row := q.db.QueryRow(ctx, getTeamPullRequestStatsByDateRange,
		arg.StartDate,
		arg.EndDate,
		arg.TeamName,
		arg.Members,
	)
	var i GetTeamPullRequestStatsByDateRangeRow
	err := row.Scan(
		&i.MergedCount,
		&i.ClosedCount,
		&i.RollbacksCount,
		&i.AvgLeadTimeToCodeSeconds,
		&i.CountPrsForAvgLeadTime,
		&i.AvgLeadTimeToReviewSeconds,
		&i.AvgLeadTimeToMergeSeconds,
		&i.CountPrsForAvgLeadTimeToMerge,
		&i.AvgTimeToFirstActualReviewSeconds,
		&i.CountPrsForAvgTimeToFirstActualReview,
		&i.TotalAdditions,
		&i.TotalDeletions,
		&i.TotalTeamReviewsSubmitted,
		&i.DistinctTeamReviewersCount,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, hashed_password, created_at, updated_at
FROM users
WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.HashedPassword,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertCommit = `-- name: InsertCommit :exec

INSERT INTO commits (id, pr_id, message, created_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO NOTHING
`

type InsertCommitParams struct {
	ID        string             `db:"id"`
	PrID      string             `db:"pr_id"`
	Message   sql.NullString     `db:"message"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
}

// Commits --
func (q *Queries) InsertCommit(ctx context.Context, arg InsertCommitParams) error {
	_, err := q.db.Exec(ctx, insertCommit,
		arg.ID,
		arg.PrID,
		arg.Message,
		arg.CreatedAt,
	)
	return err
}

const listPullRequests = `-- name: ListPullRequests :many

WITH MatchedPRs AS (
    SELECT DISTINCT p.id as pr_id -- Alias for clarity in join
    FROM prs p
    LEFT JOIN teams t ON p.author = t.member
    WHERE
        p.merged_at >= $3::timestamptz
        AND p.merged_at <= $4::timestamptz
        AND ( -- Filter by search term (title, author, or JIRA reference)
            $5::text = '' OR
            p.title ILIKE '%' || $5::text || '%' OR
            p.author ILIKE '%' || $5::text || '%' OR
            EXISTS (
                SELECT 1
                FROM regexp_matches(COALESCE(p.title, '') || ' ' || COALESCE(p.branch_name, ''), '([A-Z]+-[0-9]+)', 'g') AS s(jira_id_arr)
                WHERE jira_id_arr[1] ILIKE ('%' || $5::text || '%')
            )
        )
        AND ( -- Optionally filter by team name
            $6::text = '' OR
            t.team = $6::text
        )
        AND ( -- Optionally filter by state
            $7::text = '' OR
            p.state ILIKE '%' || $7::text || '%'
        )
        AND ( -- Optionally filter by author (case-insensitive)
            $8::text = '' OR
            p.author ILIKE '%' || $8::text || '%'
        )
        AND ($9::text[] IS NULL OR p.author = ANY($9::text[])) -- Filter by selected members
),
FirstCommitPerPR AS (
    SELECT
        pr_id,
        MIN(created_at) as first_commit_at
    FROM commits
    GROUP BY pr_id
),
FirstActualReviewPerPR AS (
    SELECT
        pull_request_id,
        MIN(submitted_at) as first_actual_review_at
    FROM pull_request_reviews
    WHERE state = 'APPROVED' OR state = 'CHANGES_REQUESTED'
    GROUP BY pull_request_id
)
SELECT
    p.id,
    p.repository_name,
    p.title,
    p.author,
    p.state,
    p.created_at AS pr_created_at,
    p.merged_at AS pr_merged_at,
    p.additions,
    p.deletions,
    p.url,
    p.review_requested_at AS pr_review_requested_at,
    p.reviews_requested AS pr_reviews_requested_count,
    fc.first_commit_at,
    far.first_actual_review_at,
    (SELECT array_agg(m[1]) FROM regexp_matches(COALESCE(p.title, '') || ' ' || COALESCE(p.branch_name, ''), '([A-Z]+-[0-9]+)', 'g') AS m) AS jira_references,
    CASE
        WHEN p.review_requested_at IS NOT NULL AND fc.first_commit_at IS NOT NULL AND p.review_requested_at > fc.first_commit_at
        THEN EXTRACT(EPOCH FROM (p.review_requested_at - fc.first_commit_at))
        ELSE NULL
    END AS lead_time_to_code_seconds,
    CASE
        WHEN p.state = 'MERGED' AND p.merged_at IS NOT NULL AND p.review_requested_at IS NOT NULL AND p.review_requested_at < p.merged_at
        THEN EXTRACT(EPOCH FROM (p.merged_at - p.review_requested_at))
        ELSE NULL
    END AS lead_time_to_review_seconds,
    CASE
        WHEN p.state = 'MERGED' AND p.merged_at IS NOT NULL AND fc.first_commit_at IS NOT NULL AND fc.first_commit_at < p.merged_at
        THEN EXTRACT(EPOCH FROM (p.merged_at - fc.first_commit_at))
        ELSE NULL
    END AS lead_time_to_merge_seconds
FROM prs p
JOIN MatchedPRs m_prs ON p.id = m_prs.pr_id -- Join with the matched PR IDs
LEFT JOIN FirstCommitPerPR fc ON p.id = fc.pr_id
LEFT JOIN FirstActualReviewPerPR far ON p.id = far.pull_request_id
ORDER BY p.merged_at DESC, p.id ASC
LIMIT $2::int
OFFSET $1::int
`

type ListPullRequestsParams struct {
	OffsetVal    int32     `db:"offset_val"`
	PageSize     int32     `db:"page_size"`
	StartDate    time.Time `db:"start_date"`
	EndDate      time.Time `db:"end_date"`
	SearchTerm   string    `db:"search_term"`
	TeamName     string    `db:"team_name"`
	FilterState  string    `db:"filter_state"`
	FilterAuthor string    `db:"filter_author"`
	Members      []string  `db:"members"`
}

type ListPullRequestsRow struct {
	ID                      string             `db:"id"`
	RepositoryName          pgtype.Text        `db:"repository_name"`
	Title                   sql.NullString     `db:"title"`
	Author                  pgtype.Text        `db:"author"`
	State                   pgtype.Text        `db:"state"`
	PrCreatedAt             time.Time          `db:"pr_created_at"`
	PrMergedAt              pgtype.Timestamptz `db:"pr_merged_at"`
	Additions               pgtype.Int4        `db:"additions"`
	Deletions               pgtype.Int4        `db:"deletions"`
	Url                     sql.NullString     `db:"url"`
	PrReviewRequestedAt     pgtype.Timestamptz `db:"pr_review_requested_at"`
	PrReviewsRequestedCount pgtype.Int4        `db:"pr_reviews_requested_count"`
	FirstCommitAt           interface{}        `db:"first_commit_at"`
	FirstActualReviewAt     interface{}        `db:"first_actual_review_at"`
	JiraReferences          interface{}        `db:"jira_references"`
	LeadTimeToCodeSeconds   interface{}        `db:"lead_time_to_code_seconds"`
	LeadTimeToReviewSeconds interface{}        `db:"lead_time_to_review_seconds"`
	LeadTimeToMergeSeconds  interface{}        `db:"lead_time_to_merge_seconds"`
}

// List Pull Requests (Paginated & Searchable by Title/Author and optionally Team) --
func (q *Queries) ListPullRequests(ctx context.Context, arg ListPullRequestsParams) ([]ListPullRequestsRow, error) {
	rows, err := q.db.Query(ctx, listPullRequests,
		arg.OffsetVal,
		arg.PageSize,
		arg.StartDate,
		arg.EndDate,
		arg.SearchTerm,
		arg.TeamName,
		arg.FilterState,
		arg.FilterAuthor,
		arg.Members,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPullRequestsRow{}
	for rows.Next() {
		var i ListPullRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.RepositoryName,
			&i.Title,
			&i.Author,
			&i.State,
			&i.PrCreatedAt,
			&i.PrMergedAt,
			&i.Additions,
			&i.Deletions,
			&i.Url,
			&i.PrReviewRequestedAt,
			&i.PrReviewsRequestedCount,
			&i.FirstCommitAt,
			&i.FirstActualReviewAt,
			&i.JiraReferences,
			&i.LeadTimeToCodeSeconds,
			&i.LeadTimeToReviewSeconds,
			&i.LeadTimeToMergeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPullRequestsWithJiraReferences = `-- name: ListPullRequestsWithJiraReferences :many

SELECT
    p.id,
    p.title,
    p.branch_name,
    p.url,
    p.author,
    p.state,
    p.created_at,
    p.merged_at,
    p.repository_name,
    p.repository_owner,
    REGEXP_MATCHES(
        COALESCE(p.title, '') || ' ' || COALESCE(p.branch_name, ''),
        '([A-Z]+-[0-9]+)'
    ) AS jira_references
FROM prs p
LEFT JOIN teams t ON p.author = t.member -- Join with teams table
WHERE
    (COALESCE(p.title, '') ~ '[A-Z]+-[0-9]+' OR COALESCE(p.branch_name, '') ~ '[A-Z]+-[0-9]+') -- Condition for having Jira refs
    AND p.created_at >= $1::timestamptz
    AND p.created_at <= $2::timestamptz
    AND ($3::text = '' OR
         p.title ILIKE '%' || $3::text || '%' OR
         p.branch_name ILIKE '%' || $3::text || '%' OR
         p.author ILIKE '%' || $3::text || '%')
    AND ($4::text = '' OR t.team = $4::text)
    AND ($5::text[] IS NULL OR p.author = ANY($5::text[]))
ORDER BY p.created_at DESC
LIMIT $7::int OFFSET $6::int
`

type ListPullRequestsWithJiraReferencesParams struct {
	StartDate      time.Time `db:"start_date"`
	EndDate        time.Time `db:"end_date"`
	TextSearchTerm string    `db:"text_search_term"`
	TeamName       string    `db:"team_name"`
	Members        []string  `db:"members"`
	OffsetVal      int32     `db:"offset_val"`
	PageSize       int32     `db:"page_size"`
}

type ListPullRequestsWithJiraReferencesRow struct {
	ID              string             `db:"id"`
	Title           sql.NullString     `db:"title"`
	BranchName      sql.NullString     `db:"branch_name"`
	Url             sql.NullString     `db:"url"`
	Author          pgtype.Text        `db:"author"`
	State           pgtype.Text        `db:"state"`
	CreatedAt       time.Time          `db:"created_at"`
	MergedAt        pgtype.Timestamptz `db:"merged_at"`
	RepositoryName  pgtype.Text        `db:"repository_name"`
	RepositoryOwner pgtype.Text        `db:"repository_owner"`
	JiraReferences  interface{}        `db:"jira_references"`
}

// Pull Request JIRA References --
func (q *Queries) ListPullRequestsWithJiraReferences(ctx context.Context, arg ListPullRequestsWithJiraReferencesParams) ([]ListPullRequestsWithJiraReferencesRow, error) {
	rows, err := q.db.Query(ctx, listPullRequestsWithJiraReferences,
		arg.StartDate,
		arg.EndDate,
		arg.TextSearchTerm,
		arg.TeamName,
		arg.Members,
		arg.OffsetVal,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPullRequestsWithJiraReferencesRow{}
	for rows.Next() {
		var i ListPullRequestsWithJiraReferencesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.BranchName,
			&i.Url,
			&i.Author,
			&i.State,
			&i.CreatedAt,
			&i.MergedAt,
			&i.RepositoryName,
			&i.RepositoryOwner,
			&i.JiraReferences,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPullRequestsWithoutJiraReferences = `-- name: ListPullRequestsWithoutJiraReferences :many
SELECT
    p.id,
    p.title,
    p.branch_name,
    p.url,
    p.author,
    p.state,
    p.created_at,
    p.merged_at,
    p.repository_name,
    p.repository_owner
FROM prs p
LEFT JOIN teams t ON p.author = t.member -- Join with teams table
WHERE
    (COALESCE(p.title, '') !~ '[A-Z]+-[0-9]+' AND COALESCE(p.branch_name, '') !~ '[A-Z]+-[0-9]+') -- Condition for NOT having Jira refs
    AND p.created_at >= $1::timestamptz
    AND p.created_at <= $2::timestamptz
    AND ($3::text = '' OR
         p.title ILIKE '%' || $3::text || '%' OR
         p.branch_name ILIKE '%' || $3::text || '%' OR
         p.author ILIKE '%' || $3::text || '%')
    AND ($4::text = '' OR t.team = $4::text)
    AND ($5::text[] IS NULL OR p.author = ANY($5::text[]))
`

type ListPullRequestsWithoutJiraReferencesParams struct {
	StartDate      time.Time `db:"start_date"`
	EndDate        time.Time `db:"end_date"`
	TextSearchTerm string    `db:"text_search_term"`
	TeamName       string    `db:"team_name"`
	Members        []string  `db:"members"`
}

type ListPullRequestsWithoutJiraReferencesRow struct {
	ID              string             `db:"id"`
	Title           sql.NullString     `db:"title"`
	BranchName      sql.NullString     `db:"branch_name"`
	Url             sql.NullString     `db:"url"`
	Author          pgtype.Text        `db:"author"`
	State           pgtype.Text        `db:"state"`
	CreatedAt       time.Time          `db:"created_at"`
	MergedAt        pgtype.Timestamptz `db:"merged_at"`
	RepositoryName  pgtype.Text        `db:"repository_name"`
	RepositoryOwner pgtype.Text        `db:"repository_owner"`
}

func (q *Queries) ListPullRequestsWithoutJiraReferences(ctx context.Context, arg ListPullRequestsWithoutJiraReferencesParams) ([]ListPullRequestsWithoutJiraReferencesRow, error) {
	rows, err := q.db.Query(ctx, listPullRequestsWithoutJiraReferences,
		arg.StartDate,
		arg.EndDate,
		arg.TextSearchTerm,
		arg.TeamName,
		arg.Members,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPullRequestsWithoutJiraReferencesRow{}
	for rows.Next() {
		var i ListPullRequestsWithoutJiraReferencesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.BranchName,
			&i.Url,
			&i.Author,
			&i.State,
			&i.CreatedAt,
			&i.MergedAt,
			&i.RepositoryName,
			&i.RepositoryOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepositories = `-- name: ListRepositories :many

SELECT org, slug, language FROM repositories
WHERE ($1::text = '' OR slug ILIKE '%' || $1 || '%')
LIMIT $2 OFFSET $3
`

type ListRepositoriesParams struct {
	Column1 string `db:"column_1"`
	Limit   int32  `db:"limit"`
	Offset  int32  `db:"offset"`
}

// Use ILIKE for case-insensitive search, handle empty search string
func (q *Queries) ListRepositories(ctx context.Context, arg ListRepositoriesParams) ([]Repository, error) {
	rows, err := q.db.Query(ctx, listRepositories, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Repository{}
	for rows.Next() {
		var i Repository
		if err := rows.Scan(&i.Org, &i.Slug, &i.Language); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDistinctTeamNamesByPrefix = `-- name: SearchDistinctTeamNamesByPrefix :many
SELECT DISTINCT team
FROM teams
WHERE team ILIKE '%' || $1 || '%' -- Case-insensitive prefix search
ORDER BY team
`

func (q *Queries) SearchDistinctTeamNamesByPrefix(ctx context.Context, dollar_1 sql.NullString) ([]string, error) {
	rows, err := q.db.Query(ctx, searchDistinctTeamNamesByPrefix, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var team string
		if err := rows.Scan(&team); err != nil {
			return nil, err
		}
		items = append(items, team)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const truncateRepositories = `-- name: TruncateRepositories :exec
TRUNCATE TABLE repositories CASCADE
`

func (q *Queries) TruncateRepositories(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncateRepositories)
	return err
}

const truncateRepositoryOwners = `-- name: TruncateRepositoryOwners :exec

TRUNCATE TABLE repository_owners
`

// Repository Owners (CODEOWNERS) --
func (q *Queries) TruncateRepositoryOwners(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncateRepositoryOwners)
	return err
}

const truncateTeams = `-- name: TruncateTeams :exec

TRUNCATE TABLE teams
`

// Teams --
func (q *Queries) TruncateTeams(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncateTeams)
	return err
}

const updateTeamGithubSlug = `-- name: UpdateTeamGithubSlug :exec

UPDATE teams SET github_team_slug = $1 WHERE team = $2
`

type UpdateTeamGithubSlugParams struct {
	GithubTeamSlug pgtype.Text `db:"github_team_slug"`
	Team           string      `db:"team"`
}

// Teams with github_team_slug --
func (q *Queries) UpdateTeamGithubSlug(ctx context.Context, arg UpdateTeamGithubSlugParams) error {
	_, err := q.db.Exec(ctx, updateTeamGithubSlug, arg.GithubTeamSlug, arg.Team)
	return err
}

const upsertPullRequest = `-- name: UpsertPullRequest :exec
INSERT INTO prs (
    id, title, state, url, merged_at, created_at, additions, deletions,
    branch_name, author, repository_name, repository_owner,
    review_requested_at, reviews_requested
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) ON CONFLICT (id)
DO UPDATE SET
    title = EXCLUDED.title,
    state = EXCLUDED.state,
    merged_at = EXCLUDED.merged_at,
    additions = EXCLUDED.additions,
    deletions = EXCLUDED.deletions,
    review_requested_at = EXCLUDED.review_requested_at,
    reviews_requested = EXCLUDED.reviews_requested
`

type UpsertPullRequestParams struct {
	ID                string             `db:"id"`
	Title             sql.NullString     `db:"title"`
	State             pgtype.Text        `db:"state"`
	Url               sql.NullString     `db:"url"`
	MergedAt          pgtype.Timestamptz `db:"merged_at"`
	CreatedAt         time.Time          `db:"created_at"`
	Additions         pgtype.Int4        `db:"additions"`
	Deletions         pgtype.Int4        `db:"deletions"`
	BranchName        sql.NullString     `db:"branch_name"`
	Author            pgtype.Text        `db:"author"`
	RepositoryName    pgtype.Text        `db:"repository_name"`
	RepositoryOwner   pgtype.Text        `db:"repository_owner"`
	ReviewRequestedAt pgtype.Timestamptz `db:"review_requested_at"`
	ReviewsRequested  pgtype.Int4        `db:"reviews_requested"`
}

func (q *Queries) UpsertPullRequest(ctx context.Context, arg UpsertPullRequestParams) error {
	_, err := q.db.Exec(ctx, upsertPullRequest,
		arg.ID,
		arg.Title,
		arg.State,
		arg.Url,
		arg.MergedAt,
		arg.CreatedAt,
		arg.Additions,
		arg.Deletions,
		arg.BranchName,
		arg.Author,
		arg.RepositoryName,
		arg.RepositoryOwner,
		arg.ReviewRequestedAt,
		arg.ReviewsRequested,
	)
	return err
}

const upsertPullRequestReview = `-- name: UpsertPullRequestReview :exec

INSERT INTO pull_request_reviews (
    id, pull_request_id, author_login, state, body, url, submitted_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) ON CONFLICT (id)
DO UPDATE SET
    state = EXCLUDED.state,
    body = EXCLUDED.body,
    submitted_at = EXCLUDED.submitted_at,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertPullRequestReviewParams struct {
	ID            string             `db:"id"`
	PullRequestID string             `db:"pull_request_id"`
	AuthorLogin   sql.NullString     `db:"author_login"`
	State         pgtype.Text        `db:"state"`
	Body          sql.NullString     `db:"body"`
	Url           sql.NullString     `db:"url"`
	SubmittedAt   pgtype.Timestamptz `db:"submitted_at"`
}

// Pull Request Reviews --
func (q *Queries) UpsertPullRequestReview(ctx context.Context, arg UpsertPullRequestReviewParams) error {
	_, err := q.db.Exec(ctx, upsertPullRequestReview,
		arg.ID,
		arg.PullRequestID,
		arg.AuthorLogin,
		arg.State,
		arg.Body,
		arg.Url,
		arg.SubmittedAt,
	)
	return err
}

const upsertRepositoryOwner = `-- name: UpsertRepositoryOwner :exec
INSERT INTO repository_owners (org, repo_slug, team_slug)
VALUES ($1, $2, $3)
ON CONFLICT (org, repo_slug, team_slug) DO NOTHING
`

type UpsertRepositoryOwnerParams struct {
	Org      string `db:"org"`
	RepoSlug string `db:"repo_slug"`
	TeamSlug string `db:"team_slug"`
}

func (q *Queries) UpsertRepositoryOwner(ctx context.Context, arg UpsertRepositoryOwnerParams) error {
	_, err := q.db.Exec(ctx, upsertRepositoryOwner, arg.Org, arg.RepoSlug, arg.TeamSlug)
	return err
}
