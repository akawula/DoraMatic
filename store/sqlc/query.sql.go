// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPullRequests = `-- name: CountPullRequests :one
SELECT COUNT(*)::int
FROM prs
WHERE
    created_at >= $1::timestamptz
    AND created_at <= $2::timestamptz
    AND (
        $3::text = '' OR
        title ILIKE '%' || $3::text || '%' OR
        author ILIKE '%' || $3::text || '%'
    )
`

type CountPullRequestsParams struct {
	StartDate  time.Time `db:"start_date"`
	EndDate    time.Time `db:"end_date"`
	SearchTerm string    `db:"search_term"`
}

func (q *Queries) CountPullRequests(ctx context.Context, arg CountPullRequestsParams) (int32, error) {
	row := q.db.QueryRow(ctx, countPullRequests, arg.StartDate, arg.EndDate, arg.SearchTerm)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countRepositories = `-- name: CountRepositories :one

SELECT count(*) FROM repositories
WHERE ($1::text = '' OR slug ILIKE '%' || $1 || '%')
`

// Repositories --
func (q *Queries) CountRepositories(ctx context.Context, dollar_1 string) (int64, error) {
	row := q.db.QueryRow(ctx, countRepositories, dollar_1)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countTeamCommitsByDateRange = `-- name: CountTeamCommitsByDateRange :one

SELECT COUNT(c.id)::int -- Cast to int for Go compatibility
FROM commits c
JOIN prs p ON c.pr_id = p.id
JOIN teams t ON p.author = t.member
WHERE t.team = $1
  AND c.created_at >= $2 -- pgtype.Timestamptz
  AND c.created_at <= $3
`

type CountTeamCommitsByDateRangeParams struct {
	Team        string             `db:"team"`
	CreatedAt   pgtype.Timestamptz `db:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `db:"created_at_2"`
}

// Team Statistics --
func (q *Queries) CountTeamCommitsByDateRange(ctx context.Context, arg CountTeamCommitsByDateRangeParams) (int32, error) {
	row := q.db.QueryRow(ctx, countTeamCommitsByDateRange, arg.Team, arg.CreatedAt, arg.CreatedAt_2)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createRepository = `-- name: CreateRepository :exec
INSERT INTO repositories (org, slug, language)
VALUES ($1, $2, $3)
`

type CreateRepositoryParams struct {
	Org      string      `db:"org"`
	Slug     string      `db:"slug"`
	Language pgtype.Text `db:"language"`
}

func (q *Queries) CreateRepository(ctx context.Context, arg CreateRepositoryParams) error {
	_, err := q.db.Exec(ctx, createRepository, arg.Org, arg.Slug, arg.Language)
	return err
}

const createTeamMember = `-- name: CreateTeamMember :exec
INSERT INTO teams (team, member, avatar_url)
VALUES ($1, $2, $3)
`

type CreateTeamMemberParams struct {
	Team      string         `db:"team"`
	Member    string         `db:"member"`
	AvatarUrl sql.NullString `db:"avatar_url"`
}

func (q *Queries) CreateTeamMember(ctx context.Context, arg CreateTeamMemberParams) error {
	_, err := q.db.Exec(ctx, createTeamMember, arg.Team, arg.Member, arg.AvatarUrl)
	return err
}

const fetchSecurityPullRequests = `-- name: FetchSecurityPullRequests :many
SELECT
    p.id, p.url, p.title, p.repository_name, p.repository_owner, p.author,
    p.additions, p.deletions, p.state, p.created_at, p.merged_at
FROM teams t
INNER JOIN prs p ON p.author = t.member
WHERE
    (p.created_at >= date_trunc('day', current_timestamp) - interval '1 day' AND p.state = 'OPEN')
    OR
    (p.merged_at >= date_trunc('day', current_timestamp) - interval '1 day' AND p.state = 'MERGED')
AND t.team IN (
    'pe-customer-journey', 'PE Platform Insights', 'Webstack', 'Omnibus', 'CSI',
    'pe-platform-fleet', 'ie-deploy', 'P&E - Team Domino', 'Ares', 'RD-Edge',
    'Golden', 'RD - Production Engineering', 'Security Engineering'
)
GROUP BY p.id
ORDER BY p.additions + p.deletions DESC
`

type FetchSecurityPullRequestsRow struct {
	ID              string             `db:"id"`
	Url             sql.NullString     `db:"url"`
	Title           sql.NullString     `db:"title"`
	RepositoryName  pgtype.Text        `db:"repository_name"`
	RepositoryOwner pgtype.Text        `db:"repository_owner"`
	Author          pgtype.Text        `db:"author"`
	Additions       pgtype.Int4        `db:"additions"`
	Deletions       pgtype.Int4        `db:"deletions"`
	State           pgtype.Text        `db:"state"`
	CreatedAt       time.Time          `db:"created_at"`
	MergedAt        pgtype.Timestamptz `db:"merged_at"`
}

func (q *Queries) FetchSecurityPullRequests(ctx context.Context) ([]FetchSecurityPullRequestsRow, error) {
	rows, err := q.db.Query(ctx, fetchSecurityPullRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FetchSecurityPullRequestsRow{}
	for rows.Next() {
		var i FetchSecurityPullRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.Title,
			&i.RepositoryName,
			&i.RepositoryOwner,
			&i.Author,
			&i.Additions,
			&i.Deletions,
			&i.State,
			&i.CreatedAt,
			&i.MergedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRepositories = `-- name: GetAllRepositories :many
SELECT org, slug, language FROM repositories
`

func (q *Queries) GetAllRepositories(ctx context.Context) ([]Repository, error) {
	rows, err := q.db.Query(ctx, getAllRepositories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Repository{}
	for rows.Next() {
		var i Repository
		if err := rows.Scan(&i.Org, &i.Slug, &i.Language); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastPullRequestMergedDate = `-- name: GetLastPullRequestMergedDate :one

SELECT merged_at FROM prs
WHERE state = $1 AND repository_owner = $2 AND repository_name = $3
ORDER BY merged_at DESC
LIMIT 1
`

type GetLastPullRequestMergedDateParams struct {
	State           pgtype.Text `db:"state"`
	RepositoryOwner pgtype.Text `db:"repository_owner"`
	RepositoryName  pgtype.Text `db:"repository_name"`
}

// Pull Requests (prs) --
func (q *Queries) GetLastPullRequestMergedDate(ctx context.Context, arg GetLastPullRequestMergedDateParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getLastPullRequestMergedDate, arg.State, arg.RepositoryOwner, arg.RepositoryName)
	var merged_at pgtype.Timestamptz
	err := row.Scan(&merged_at)
	return merged_at, err
}

const getTeamPullRequestStatsByDateRange = `-- name: GetTeamPullRequestStatsByDateRange :one

SELECT
    COUNT(CASE WHEN p.state = 'OPEN' AND p.created_at >= $2 AND p.created_at <= $3 THEN 1 END)::int AS open_count,
    COUNT(CASE WHEN p.state = 'MERGED' AND p.merged_at >= $2 AND p.merged_at <= $3 THEN 1 END)::int AS merged_count,
    -- Assuming 'CLOSED' is a state and filtering by created_at. Adjust if logic differs.
    COUNT(CASE WHEN p.state = 'CLOSED' AND p.created_at >= $2 AND p.created_at <= $3 THEN 1 END)::int AS closed_count,
    -- Count rollbacks: Merged PRs within the date range whose title starts with 'Revert '
    COUNT(CASE WHEN p.state = 'MERGED' AND p.merged_at >= $2 AND p.merged_at <= $3 AND p.title LIKE 'Revert %' THEN 1 END)::int AS rollbacks_count
FROM prs p
JOIN teams t ON p.author = t.member
WHERE t.team = $1
  AND (
       (p.state = 'OPEN' AND p.created_at >= $2 AND p.created_at <= $3) OR
       (p.state = 'MERGED' AND p.merged_at >= $2 AND p.merged_at <= $3) OR
       (p.state = 'CLOSED' AND p.created_at >= $2 AND p.created_at <= $3)
      )
`

type GetTeamPullRequestStatsByDateRangeParams struct {
	Team        string    `db:"team"`
	CreatedAt   time.Time `db:"created_at"`
	CreatedAt_2 time.Time `db:"created_at_2"`
}

type GetTeamPullRequestStatsByDateRangeRow struct {
	OpenCount      int32 `db:"open_count"`
	MergedCount    int32 `db:"merged_count"`
	ClosedCount    int32 `db:"closed_count"`
	RollbacksCount int32 `db:"rollbacks_count"`
}

// pgtype.Timestamptz
func (q *Queries) GetTeamPullRequestStatsByDateRange(ctx context.Context, arg GetTeamPullRequestStatsByDateRangeParams) (GetTeamPullRequestStatsByDateRangeRow, error) {
	row := q.db.QueryRow(ctx, getTeamPullRequestStatsByDateRange, arg.Team, arg.CreatedAt, arg.CreatedAt_2)
	var i GetTeamPullRequestStatsByDateRangeRow
	err := row.Scan(
		&i.OpenCount,
		&i.MergedCount,
		&i.ClosedCount,
		&i.RollbacksCount,
	)
	return i, err
}

const insertCommit = `-- name: InsertCommit :exec

INSERT INTO commits (id, pr_id, message, created_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO NOTHING
`

type InsertCommitParams struct {
	ID        string             `db:"id"`
	PrID      string             `db:"pr_id"`
	Message   sql.NullString     `db:"message"`
	CreatedAt pgtype.Timestamptz `db:"created_at"`
}

// Commits --
func (q *Queries) InsertCommit(ctx context.Context, arg InsertCommitParams) error {
	_, err := q.db.Exec(ctx, insertCommit,
		arg.ID,
		arg.PrID,
		arg.Message,
		arg.CreatedAt,
	)
	return err
}

const listPullRequests = `-- name: ListPullRequests :many

SELECT
    id,
    repository_name,
    title,
    author,
    state,
    created_at,
    merged_at,
    -- closed_at column does not exist, state indicates closure
    url
FROM prs
WHERE
    created_at >= $1::timestamptz
    AND created_at <= $2::timestamptz
    AND (
        $3::text = '' OR
        title ILIKE '%' || $3::text || '%' OR
        author ILIKE '%' || $3::text || '%'
    )
ORDER BY created_at DESC -- Or another relevant field like id
LIMIT $5::int
OFFSET $4::int
`

type ListPullRequestsParams struct {
	StartDate  time.Time `db:"start_date"`
	EndDate    time.Time `db:"end_date"`
	SearchTerm string    `db:"search_term"`
	OffsetVal  int32     `db:"offset_val"`
	PageSize   int32     `db:"page_size"`
}

type ListPullRequestsRow struct {
	ID             string             `db:"id"`
	RepositoryName pgtype.Text        `db:"repository_name"`
	Title          sql.NullString     `db:"title"`
	Author         pgtype.Text        `db:"author"`
	State          pgtype.Text        `db:"state"`
	CreatedAt      time.Time          `db:"created_at"`
	MergedAt       pgtype.Timestamptz `db:"merged_at"`
	Url            sql.NullString     `db:"url"`
}

// List Pull Requests (Paginated & Searchable) --
func (q *Queries) ListPullRequests(ctx context.Context, arg ListPullRequestsParams) ([]ListPullRequestsRow, error) {
	rows, err := q.db.Query(ctx, listPullRequests,
		arg.StartDate,
		arg.EndDate,
		arg.SearchTerm,
		arg.OffsetVal,
		arg.PageSize,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPullRequestsRow{}
	for rows.Next() {
		var i ListPullRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.RepositoryName,
			&i.Title,
			&i.Author,
			&i.State,
			&i.CreatedAt,
			&i.MergedAt,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRepositories = `-- name: ListRepositories :many

SELECT org, slug, language FROM repositories
WHERE ($1::text = '' OR slug ILIKE '%' || $1 || '%')
LIMIT $2 OFFSET $3
`

type ListRepositoriesParams struct {
	Column1 string `db:"column_1"`
	Limit   int32  `db:"limit"`
	Offset  int32  `db:"offset"`
}

// Use ILIKE for case-insensitive search, handle empty search string
func (q *Queries) ListRepositories(ctx context.Context, arg ListRepositoriesParams) ([]Repository, error) {
	rows, err := q.db.Query(ctx, listRepositories, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Repository{}
	for rows.Next() {
		var i Repository
		if err := rows.Scan(&i.Org, &i.Slug, &i.Language); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchDistinctTeamNamesByPrefix = `-- name: SearchDistinctTeamNamesByPrefix :many
SELECT DISTINCT team
FROM teams
WHERE team ILIKE $1 || '%' -- Case-insensitive prefix search
ORDER BY team
`

func (q *Queries) SearchDistinctTeamNamesByPrefix(ctx context.Context, dollar_1 sql.NullString) ([]string, error) {
	rows, err := q.db.Query(ctx, searchDistinctTeamNamesByPrefix, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var team string
		if err := rows.Scan(&team); err != nil {
			return nil, err
		}
		items = append(items, team)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const truncateRepositories = `-- name: TruncateRepositories :exec
TRUNCATE TABLE repositories
`

func (q *Queries) TruncateRepositories(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncateRepositories)
	return err
}

const truncateTeams = `-- name: TruncateTeams :exec

TRUNCATE TABLE teams
`

// Teams --
func (q *Queries) TruncateTeams(ctx context.Context) error {
	_, err := q.db.Exec(ctx, truncateTeams)
	return err
}

const upsertPullRequest = `-- name: UpsertPullRequest :exec
INSERT INTO prs (
    id, title, state, url, merged_at, created_at, additions, deletions,
    branch_name, author, repository_name, repository_owner,
    review_requested_at, reviews_requested
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
) ON CONFLICT (id)
DO UPDATE SET
    title = EXCLUDED.title,
    state = EXCLUDED.state,
    merged_at = EXCLUDED.merged_at,
    additions = EXCLUDED.additions,
    deletions = EXCLUDED.deletions,
    review_requested_at = EXCLUDED.review_requested_at,
    reviews_requested = EXCLUDED.reviews_requested
`

type UpsertPullRequestParams struct {
	ID                string             `db:"id"`
	Title             sql.NullString     `db:"title"`
	State             pgtype.Text        `db:"state"`
	Url               sql.NullString     `db:"url"`
	MergedAt          pgtype.Timestamptz `db:"merged_at"`
	CreatedAt         time.Time          `db:"created_at"`
	Additions         pgtype.Int4        `db:"additions"`
	Deletions         pgtype.Int4        `db:"deletions"`
	BranchName        sql.NullString     `db:"branch_name"`
	Author            pgtype.Text        `db:"author"`
	RepositoryName    pgtype.Text        `db:"repository_name"`
	RepositoryOwner   pgtype.Text        `db:"repository_owner"`
	ReviewRequestedAt pgtype.Timestamptz `db:"review_requested_at"`
	ReviewsRequested  pgtype.Int4        `db:"reviews_requested"`
}

func (q *Queries) UpsertPullRequest(ctx context.Context, arg UpsertPullRequestParams) error {
	_, err := q.db.Exec(ctx, upsertPullRequest,
		arg.ID,
		arg.Title,
		arg.State,
		arg.Url,
		arg.MergedAt,
		arg.CreatedAt,
		arg.Additions,
		arg.Deletions,
		arg.BranchName,
		arg.Author,
		arg.RepositoryName,
		arg.RepositoryOwner,
		arg.ReviewRequestedAt,
		arg.ReviewsRequested,
	)
	return err
}

const upsertPullRequestReview = `-- name: UpsertPullRequestReview :exec

INSERT INTO pull_request_reviews (
    id, pull_request_id, author_login, state, body, url, submitted_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) ON CONFLICT (id)
DO UPDATE SET
    state = EXCLUDED.state,
    body = EXCLUDED.body,
    submitted_at = EXCLUDED.submitted_at,
    updated_at = CURRENT_TIMESTAMP
`

type UpsertPullRequestReviewParams struct {
	ID            string             `db:"id"`
	PullRequestID string             `db:"pull_request_id"`
	AuthorLogin   sql.NullString     `db:"author_login"`
	State         pgtype.Text        `db:"state"`
	Body          sql.NullString     `db:"body"`
	Url           sql.NullString     `db:"url"`
	SubmittedAt   pgtype.Timestamptz `db:"submitted_at"`
}

// Pull Request Reviews --
func (q *Queries) UpsertPullRequestReview(ctx context.Context, arg UpsertPullRequestReviewParams) error {
	_, err := q.db.Exec(ctx, upsertPullRequestReview,
		arg.ID,
		arg.PullRequestID,
		arg.AuthorLogin,
		arg.State,
		arg.Body,
		arg.Url,
		arg.SubmittedAt,
	)
	return err
}
